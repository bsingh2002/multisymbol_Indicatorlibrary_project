//+------------------------------------------------------------------+
//|                              Multi-Symbol-Indicator-Ea-v2.01.mq5 |
//|                                     Copyright 2024, Dillon Grech |
//|                   YouTube: https://www.youtube.com/c/DillonGrech |
//|                           GitHub: https://github.com/DillonGrech |
//|                           Discord: https://discord.gg/xs3KpdUjSu |
//+------------------------------------------------------------------+
//|                                                  Version Notes 2 |
//| This file uses multi-symbol functionality. This EA incorporates  |
//| trigger and filter indicators to find the best combination of    |
//| indicators. Indicator signals are taked from Indicator Library.  |
//| EA will use enums so user can select the indicator and params.   |
//+------------------------------------------------------------------+
//|                                                    Patch Notes 1 |
//| Completed version for the youtube tutorial.                      |
//|                                                                  |
//|                                                                  |
//|                                                                  |
//+------------------------------------------------------------------+
//|                                              Strategy Conditions |
//| Long & short trades, 1x EntryTrigger, 2x Filter, 1x Exit Trigger |
//| Fixed position size and no stop loss (exit on exit trigger).     |
//| Exit trigger is also filter indicator 1.                         |
//|                                                                  |
//+------------------------------------------------------------------+

#property copyright "Copyright 2024, Dillon Grech"
#property version   "2.01"

//+------------------------------------------------------------------+
//| Expert Setup                                                     |
//+------------------------------------------------------------------+
//Libraries
#import "IndicatorLibrary.ex5"
   int    GetIndicatorHandle(string Indicator, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   string GetIndicatorTrigger(string Indicator, int IndicatorHandle, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   string GetIndicatorFilter(string Indicator, int IndicatorHandle, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   double GetIndicatorValue(int IndicatorHandle, int BufferValue);
#import

//Include
#include  <Trade\Trade.mqh> //Include MQL trade object functions
CTrade    *Trade;           //Declaire Trade as pointer to CTrade class

//Select expert magic number
input int MagicNumber = 1;  //Unique Identifier

//Multi-Symbol EA Variables - User can specify "Current" within input to trade current symbol only
input string AllTradableSymbols = "AUDJPY|CHFJPY|EURJPY|GBPJPY|USDJPY|AUDCHF|CADCHF|EURCHF|GBPCHF|USDCHF|AUDCAD|USDCAD|AUDUSD|EURUSD|GBPUSD|NZDUSD|AUDNZD|EURGBP";
int    NumberOfTradeableSymbols;
string SymbolArray[];

//Expert Core Arrays
string          SymbolMetrics[];
ulong           TicksProcessed[];
static datetime TimeLastTickProcessed[];
ulong           TicketNumber[];

//Expert Variables
string ExpertComments = "";
int    TicksReceived  =  0;
int HandleAtr[];   // ATR handle per symbol


//Risk Metrics
input bool   RiskCompounding = false; // false = use StartingEquity, true = use current equity
input double RiskPercent     = 0.01;  // 0.01 = 1% risk per trade
double       StartingEquity  = 0.0;

// ATR SL/TP inputs
input int    AtrPeriod      = 14;
input double AtrLossMulti   = 1.0;  // ATR - SL
input double AtrProfitMulti = 2.0;  // ATR - TP


//+------------------------------------------------------------------+
//| Indicator String Setup                                           |
//+------------------------------------------------------------------+
//Indicator Entry 1 String
enum   INDICATORSE1 
{
    E1_NA,Doda_A_8_30_8, Doda_A_8_34_8, Doda_A_8_55_8, Doda_A_8_42_8, Doda_A_9_34_9, Doda_A_10_30_10, Doda_A_10_34_10, Doda_A_10_38_10, Doda_A_10_42_10, Doda_A_10_55_10, Doda_A_10_68_10, Doda_A_11_34_10, Doda_A_13_42_10, Doda_A_13_55_10, Doda_A_13_68_10, Doda_A_13_55_13, Doda_A_13_68_13, Doda_A_16_42_13, Doda_A_16_55_13

};
input INDICATORSE1 InputEnumE1;

//Indicator Filter 1 String
enum   INDICATORSF1 
{
    F1_NA,Pfe_A_6_1_3, Pfe_A_7_1_3, Pfe_A_6_1_5, Pfe_A_7_1_5, Pfe_A_8_1_5, Pfe_B_3_1_3, Pfe_B_4_1_3, Pfe_B_5_1_3


   
};
input INDICATORSF1 InputEnumF1;

//Indicator Filter 2 String
enum INDICATORSF2 
{
   F2_NA,Ema_B_10, Ema_B_11, Ema_B_12, Ema_B_13, Ema_B_14, Ema_B_40, Ema_B_45, Ema_B_65, Ema_B_70, Ema_B_75, Ema_B_90, Ema_B_100, Ema_B_120, Ema_B_150, Ema_B_300,
   Smma_B_6, Smma_B_7, Smma_B_19, Smma_B_20, Smma_B_34, Smma_B_36, Smma_B_38,
   Lwma_B_12, Lwma_B_22, Lwma_A_26, Lwma_B_60, Lwma_B_65, Lwma_B_70, Lwma_B_90, Lwma_B_100, Lwma_B_140,
   Frama_A_12, Frama_A_13, Frama_A_14, Frama_A_48, Frama_A_50, Frama_A_55, Frama_B_22, Frama_B_26, Frama_B_34, Frama_B_85, Frama_B_95, Frama_B_100, Frama_B_110, Frama_B_120, Frama_B_220, Frama_B_240, Frama_B_260


};
input INDICATORSF2 InputEnumF2;

//Indicator Filter 3 String (Volume / future filters)
enum INDICATORSF3
{
   F3_NA
   
};
input INDICATORSF3 InputEnumF3;

//+------------------------------------------------------------------+
//| Indicator Setup                                                  |
//+------------------------------------------------------------------+
//Indicator Entry 1 Variables - Entry Trigger
string IndicatorE1 = (InputEnumE1 == E1_NA) ? "Na" : EnumToString(InputEnumE1);
string IndicatorSignalE1;
int    IndicatorHandleE1[];

//Indicator Filter 1 Variables
string IndicatorF1 = (InputEnumF1 == F1_NA) ? "Na" : EnumToString(InputEnumF1);
string IndicatorSignalF1;
int    IndicatorHandleF1[];

//Indicator Filter 2 Variables
string IndicatorF2 = (InputEnumF2 == F2_NA) ? "Na" : EnumToString(InputEnumF2);
string IndicatorSignalF2;
int    IndicatorHandleF2[];

//Indicator Filter 3 Variables
string IndicatorF3 = (InputEnumF3 == F3_NA) ? "Na" : EnumToString(InputEnumF3);
string IndicatorSignalF3;
int    IndicatorHandleF3[];

//Indicator Exit 1 Variables - Exit Trigger
string IndicatorX1 = (InputEnumF1 == F1_NA) ? "Na" : EnumToString(InputEnumF1);
string IndicatorSignalX1;
int    IndicatorHandleX1[];

double GetAtrConfirmed(int atrHandle)
{
   double buf[];
   // Copy 3 values from shift 0:
   // buf[0] = current forming bar
   // buf[1] = last closed bar  <-- we want this
   // buf[2] = older bar
   if(CopyBuffer(atrHandle, 0, 0, 3, buf) <= 0)
   {
      Print("ATR CopyBuffer failed. err=", GetLastError());
      return 0.0;
   }

   return buf[1];
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   //Initiate C Trade
   InitiateTrade(MagicNumber);
   
   StartingEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   //Set up multi-symbol EA Tradable Symbols
   InitMultiSymbol();

   //Resize Arrays for Multi-Symbol EA
   ResizeCoreArrays();   
   
   //Resize Indicator Arrays for Multi-Symbol EA
   ResizeIndicatorArrays();

   //Initiate indicator handles for multi-symbol
   if(!InitIndicatorHanldes())
       return(INIT_FAILED);
      
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //Release Indicator Arrays
   ReleaseIndicatorHandles();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   //Declare comment variables
   ExpertComments="";
   TicksReceived++;
  
   //Run multi-symbol loop   
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      //Store symbol vairables
      string CurrentSymbol = SymbolArray[SymbolLoop]; //Get current symbol

      
      //Check for new candle based of opening time of bar 
      if(TimeLastTickProcessed[SymbolLoop] != iTime(CurrentSymbol,Period(),0))
      {
         //Add to tick processed counter and store last tick processed for symbol
         TicksProcessed[SymbolLoop]++; 
         TimeLastTickProcessed[SymbolLoop]  = iTime(CurrentSymbol,Period(),0);  
         
         double atr = GetAtrConfirmed(HandleAtr[SymbolLoop]);
          //Print("ATR confirmed for ", CurrentSymbol, " = ", DoubleToString(atr, 6));
    
         
         //Get any open position directions, reset on each run
         string PositionDirection = "NA";                  
         if(PositionSelectByTicket(TicketNumber[SymbolLoop]) == true)
         {
            if (PositionGetInteger(POSITION_TYPE) == 0)
               PositionDirection = "Long";
            else if (PositionGetInteger(POSITION_TYPE) == 1)
               PositionDirection = "Short";
         }
         else
            PositionDirection = "NA";
           
         //Get Indicator Signals
         IndicatorSignalE1 = GetIndicatorTrigger(IndicatorE1, IndicatorHandleE1[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalF1 = GetIndicatorFilter(IndicatorF1,  IndicatorHandleF1[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalF2 = GetIndicatorFilter(IndicatorF2,  IndicatorHandleF2[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalF3 = GetIndicatorFilter(IndicatorF3,  IndicatorHandleF3[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalX1 = GetIndicatorTrigger(IndicatorX1, IndicatorHandleX1[SymbolLoop], CurrentSymbol, Period());
         
                     
         //Enter Long Trades
         if(
            (PositionDirection == "Short" || PositionDirection == "NA") && //enter if no current trades or short trades
            (IndicatorSignalE1 == "Long"                              ) && //enter on long trigger
            (IndicatorSignalF1 == "Long"  || IndicatorSignalF1 == "NA") && //enter on long filter or no filter indicator is selected
            (IndicatorSignalF2 == "Long"  || IndicatorSignalF2 == "NA") && //enter on long filter or no filter indicator is selected
            (IndicatorSignalF3 == "Long"  || IndicatorSignalF3 == "NA")     //enter on long filter or no filter indicator is selected
         )
         {
            TicketNumber[SymbolLoop] = ProcessTradeOpen(CurrentSymbol, ORDER_TYPE_BUY,MagicNumber,atr);       //Open positions and store ticket
            PositionDirection        = "Long";                                                                //Store position direction
         }        
         //Enter Short Trades
         else if(
            (PositionDirection == "Long"  || PositionDirection == "NA") && //enter if no current trades or short trades
            (IndicatorSignalE1 == "Short"                             ) && //enter on short trigger
            (IndicatorSignalF1 == "Short" || IndicatorSignalF1 == "NA") && //enter on short filter or no filter indicator is selected
            (IndicatorSignalF2 == "Short" || IndicatorSignalF2 == "NA") && //enter on short filter or no filter indicator is selected
            (IndicatorSignalF3 == "Short" || IndicatorSignalF3 == "NA")    //enter on short filter or no filter indicator is selected
         )
         {
            TicketNumber[SymbolLoop] = ProcessTradeOpen(CurrentSymbol, ORDER_TYPE_SELL, MagicNumber, atr);     //Open positions and store ticket
            PositionDirection        = "Short";                                                                //Store position direction
         }     
         //Exit Trades  
         else if(
            (PositionDirection == "Long"  && IndicatorSignalX1 == "Short") || //exit long trades on exit indicator short signal
            (PositionDirection == "Short" && IndicatorSignalX1 == "Long")     //exit short trades on exit indicator long signal
         )
         {   
            ProcessTradeClose(CurrentSymbol,TicketNumber[SymbolLoop]);
         }                          
         //Update Symbol Metrics
         SymbolMetrics[SymbolLoop] = CurrentSymbol + 
                                     " | Ticks Processed: " + IntegerToString(TicksProcessed[SymbolLoop]) +
                                     " | Last Candle: " + TimeToString(TimeLastTickProcessed[SymbolLoop]) +
                                     " | Open Ticket: " + IntegerToString(TicketNumber[SymbolLoop]) +
                                     " | Open Ticket Direction: " + PositionDirection +
                                     " | Entry 1 (" + IntegerToString(IndicatorHandleE1[SymbolLoop])+") : " + IndicatorSignalE1 +
                                     " | Filter 1 (" + IntegerToString(IndicatorHandleF1[SymbolLoop])+") : " + IndicatorSignalF1 +
                                     " | Filter 2 (" + IntegerToString(IndicatorHandleF2[SymbolLoop])+") : " + IndicatorSignalF2 +
                                     " | Exit 1 (" + IntegerToString(IndicatorHandleX1[SymbolLoop])+") : " + IndicatorSignalX1                     
                                     ;
      }
      
      //Update expert comments for each symbol
      ExpertComments = ExpertComments + SymbolMetrics[SymbolLoop] + "\n\r";
   }
   //Comment expert behaviour
   Comment("\n\rExpert: ", MagicNumber, "\n\r",
            "MT5 Server Time: ", TimeCurrent(), "\n\r",
            "Ticks Received: ", TicksReceived,"\n\r\n\r",  
            "Symbols Traded:\n\r", 
            ExpertComments
            );
}

//+------------------------------------------------------------------+
//| Multi-Symbol Custom Functions                                    |
//+------------------------------------------------------------------+
//Initiate MultiSymbol Function
void InitMultiSymbol() 
{
   //Set up symbol arrays
   //If current symbol, select symbol from EA settings
   if(AllTradableSymbols == "Current")
   {
      NumberOfTradeableSymbols = 1;
      ArrayResize(SymbolArray,NumberOfTradeableSymbols);
      SymbolArray[0] = Symbol();
      Print("EA will process ", NumberOfTradeableSymbols, " Symbol: ", SymbolArray[0]);
   } 
   //Else test all symbols
   else
   {
      NumberOfTradeableSymbols = StringSplit(AllTradableSymbols, '|', SymbolArray);
      ArrayResize(SymbolArray,NumberOfTradeableSymbols);
      Print("EA will process ", NumberOfTradeableSymbols, " Symbols: ", AllTradableSymbols);
   }
}

//Resize core arrays for multi-symbol EA
void ResizeCoreArrays()
{
   //Resize core arrays for Multi-Symbol EA
   ArrayResize(SymbolMetrics,         NumberOfTradeableSymbols);
   ArrayResize(TicksProcessed,        NumberOfTradeableSymbols); 
   ArrayResize(TimeLastTickProcessed, NumberOfTradeableSymbols);
   ArrayResize(TicketNumber,          NumberOfTradeableSymbols);
}
//+------------------------------------------------------------------+
//| Indicator library custom functions                               |
//+------------------------------------------------------------------+
//Resize indicator arrays for Multi-Symbol EA
void ResizeIndicatorArrays()
{
   ArrayResize(IndicatorHandleE1, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleF1, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleF2, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleF3, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleX1, NumberOfTradeableSymbols);
   ArrayResize(HandleAtr,         NumberOfTradeableSymbols);
}


//Release indicator handles from Metatrader cache for multi-symbol EA
void ReleaseIndicatorHandles()
{
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      IndicatorRelease(IndicatorHandleE1[SymbolLoop]);
      IndicatorRelease(IndicatorHandleF1[SymbolLoop]);
      IndicatorRelease(IndicatorHandleF2[SymbolLoop]);
      IndicatorRelease(IndicatorHandleF3[SymbolLoop]);
      IndicatorRelease(IndicatorHandleX1[SymbolLoop]);
      IndicatorRelease(HandleAtr[SymbolLoop]);
   }
   Print("Handle released for all symbols");   
}

//Set up Indicator1 Handle for Multi-Symbol EA
bool InitIndicatorHanldes()
{
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      IndicatorHandleE1[SymbolLoop] = GetIndicatorHandle(IndicatorE1, SymbolArray[SymbolLoop],Period());
      IndicatorHandleF1[SymbolLoop] = GetIndicatorHandle(IndicatorF1, SymbolArray[SymbolLoop],Period());
      IndicatorHandleF2[SymbolLoop] = GetIndicatorHandle(IndicatorF2, SymbolArray[SymbolLoop],Period());
      IndicatorHandleF3[SymbolLoop] = GetIndicatorHandle(IndicatorF3, SymbolArray[SymbolLoop],Period());
      IndicatorHandleX1[SymbolLoop] = GetIndicatorHandle(IndicatorX1, SymbolArray[SymbolLoop],Period());
      
      // ATR handle per symbol
      HandleAtr[SymbolLoop] = iATR(SymbolArray[SymbolLoop], Period(), AtrPeriod);
      if(HandleAtr[SymbolLoop] == INVALID_HANDLE)
      {
         Print("Failed to create ATR handle for ", SymbolArray[SymbolLoop], " err=", GetLastError());
         return false;
      }
   }
   return true;     
}

//+------------------------------------------------------------------+
//| Process trades custom functions                                  |
//+------------------------------------------------------------------+
//Initiate cTrade and magic number
void InitiateTrade(int ID)
{   
   Trade = new CTrade();
   Trade.SetExpertMagicNumber(ID);
   return;  
}

double CalcRiskLots(string symbol, ENUM_ORDER_TYPE type, double entry, double sl)
{
   double equityForRisk = RiskCompounding ? AccountInfoDouble(ACCOUNT_EQUITY) : StartingEquity;
   double riskMoney     = equityForRisk * RiskPercent;

   // Calculate loss for 1 lot if SL is hit
   double profit = 0.0;
   if(!OrderCalcProfit(type, symbol, 1.0, entry, sl, profit))
   {
      Print("OrderCalcProfit failed for ", symbol, " err=", GetLastError());
      return 0.0;
   }

   double riskPerLot = MathAbs(profit);
   if(riskPerLot <= 0.0)
      return 0.0;

   double lots = riskMoney / riskPerLot;

   // Normalize lots to broker rules
   double volMin  = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double volMax  = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   double volStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);

   lots = MathFloor(lots / volStep) * volStep;

   if(lots < volMin) lots = volMin;
   if(lots > volMax) lots = volMax;

   return lots;
}


//Process trades function - Fixed Lot Position Size, No SL/TP
ulong ProcessTradeOpen(string CurrentSymbol, ENUM_ORDER_TYPE OrderType, int ID, double AtrValue) export

{
   //Set symbol string and variables 
   int    SymbolDigits    = (int) SymbolInfoInteger(CurrentSymbol,SYMBOL_DIGITS); //note - typecast required to remove error
   double Price           = 0.0;
   double StopLossPrice   = 0.0;
   double TakeProfitPrice = 0.0;
   
   //Open buy or sell orders
   if(OrderType == ORDER_TYPE_BUY)
   {
      Price = NormalizeDouble(SymbolInfoDouble(CurrentSymbol, SYMBOL_ASK), SymbolDigits);
   } 
   else if(OrderType == ORDER_TYPE_SELL)
   {
      Price = NormalizeDouble(SymbolInfoDouble(CurrentSymbol, SYMBOL_BID), SymbolDigits);
   }
   
    if(AtrValue <= 0.0)
   {
      Print("ATR not ready for ", CurrentSymbol, " - skipping trade open.");
      return 0;
   }
   
   if(OrderType == ORDER_TYPE_BUY)
   {
      StopLossPrice   = NormalizeDouble(Price - (AtrValue * AtrLossMulti), SymbolDigits);
      TakeProfitPrice = NormalizeDouble(Price + (AtrValue * AtrProfitMulti), SymbolDigits);
   }
   else if(OrderType == ORDER_TYPE_SELL)
   {
      StopLossPrice   = NormalizeDouble(Price + (AtrValue * AtrLossMulti), SymbolDigits);
      TakeProfitPrice = NormalizeDouble(Price - (AtrValue * AtrProfitMulti), SymbolDigits);
   }
   
   // --- NNFX risk-based lot sizing (uses ATR stop distance) ---
   double Lots = CalcRiskLots(CurrentSymbol, OrderType, Price, StopLossPrice);

   if(Lots <= 0.0)
   {
      Print("Lot calc failed for ", CurrentSymbol, " - skipping trade.");
      return 0;
   }
  

        
   //Close any current positions and open new position
   Trade.PositionClose(CurrentSymbol);
   Trade.SetExpertMagicNumber(ID);  
   Trade.PositionOpen(CurrentSymbol,OrderType,Lots,Price,StopLossPrice,TakeProfitPrice,__FILE__);
   
   
   //Get Position Ticket Number - run through open positions and store ticket number whcih matches with current symbol
   //Note - history deals total does not work for multisymbol
   ulong  Ticket = 0;
   int Total = PositionsTotal();
   for (int i=Total -1; i>=0; i--)
      {
         ulong GetTicket  = PositionGetTicket(i);
         string GetSymbol = PositionGetSymbol(i);
         if (CurrentSymbol == GetSymbol)
            Ticket = GetTicket;
      }
   
   //Print successful
   Print("Trade Processed For Ticket ", Ticket, " Symbol ", CurrentSymbol," OrderType ",OrderType, " Lot Size ", Lots);
   
   return(Ticket);
}

//Process trades close
void   ProcessTradeClose(string CurrentSymbol, ulong Ticket) export
{
   Trade.PositionClose(Ticket);
   
   //Print successful
   Print("Trade Closed For Ticket ", Ticket, " Symbol ", CurrentSymbol);
}
//+------------------------------------------------------------------+
