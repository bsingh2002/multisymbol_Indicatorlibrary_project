//+------------------------------------------------------------------+
//|                              Multi-Symbol-Indicator-Ea-v2.01.mq5 |
//|                                     Copyright 2024, Dillon Grech |
//|                   YouTube: https://www.youtube.com/c/DillonGrech |
//|                           GitHub: https://github.com/DillonGrech |
//|                           Discord: https://discord.gg/xs3KpdUjSu |
//+------------------------------------------------------------------+
//|                                                  Version Notes 2 |
//| This file uses multi-symbol functionality. This EA incorporates  |
//| trigger and filter indicators to find the best combination of    |
//| indicators. Indicator signals are taked from Indicator Library.  |
//| EA will use enums so user can select the indicator and params.   |
//+------------------------------------------------------------------+
//|                                                    Patch Notes 1 |
//| Completed version for the youtube tutorial.                      |
//|                                                                  |
//|                                                                  |
//|                                                                  |
//+------------------------------------------------------------------+
//|                                              Strategy Conditions |
//| Long & short trades, 1x EntryTrigger, 2x Filter, 1x Exit Trigger |
//| Fixed position size and no stop loss (exit on exit trigger).     |
//| Exit trigger is also filter indicator 1.                         |
//|                                                                  |
//+------------------------------------------------------------------+

#property copyright "Copyright 2024, Dillon Grech"
#property version   "2.01"

//+------------------------------------------------------------------+
//| Expert Setup                                                     |
//+------------------------------------------------------------------+
//Libraries
#import "IndicatorLibrary.ex5"
   int    GetIndicatorHandle(string Indicator, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   string GetIndicatorTrigger(string Indicator, int IndicatorHandle, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   string GetIndicatorFilter(string Indicator, int IndicatorHandle, string CurrentSymbol, ENUM_TIMEFRAMES CurrentPeriod);
   double GetIndicatorValue(int IndicatorHandle, int BufferValue);
#import

//Include
#include  <Trade\Trade.mqh> //Include MQL trade object functions
CTrade    *Trade;           //Declaire Trade as pointer to CTrade class

//Select expert magic number
input int MagicNumber = 1;  //Unique Identifier

//Multi-Symbol EA Variables - User can specify "Current" within input to trade current symbol only
input string AllTradableSymbols = "AUDJPY|CHFJPY|EURJPY|GBPJPY|USDJPY|AUDCHF|CADCHF|EURCHF|GBPCHF|USDCHF|AUDCAD|USDCAD|AUDUSD|EURUSD|GBPUSD|NZDUSD|AUDNZD|EURGBP";
int    NumberOfTradeableSymbols;
string SymbolArray[];

//Expert Core Arrays
string          SymbolMetrics[];
ulong           TicksProcessed[];
static datetime TimeLastTickProcessed[];
ulong           TicketNumber[];

//Expert Variables
string ExpertComments = "";
int    TicksReceived  =  0;
int HandleAtr[];   // ATR handle per symbol


//Risk Metrics
input bool   RiskCompounding = false; // false = use StartingEquity, true = use current equity
input double RiskPercent     = 0.01;  // 0.01 = 1% risk per trade
double       StartingEquity  = 0.0;

// ATR SL/TP inputs
input int    AtrPeriod      = 14;
input double AtrLossMulti   = 1.0;  // ATR - SL
input double AtrProfitMulti = 2.0;  // ATR - TP


//+------------------------------------------------------------------+
//| Indicator String Setup                                           |
//+------------------------------------------------------------------+
//Indicator Entry 1 String
enum   INDICATORSE1 
{
    E1_NA
   ,Macd_B_12_26_9,Macd_B_5_35_5,Macd_B_8_17_9,Macd_B_10_25_5,Macd_B_13_21_8,Macd_B_15_30_8
};
input INDICATORSE1 InputEnumE1;

//Indicator Filter 1 String
enum   INDICATORSF1 
{
    F1_NA
   ,Ema_B_10,Ema_B_20,Ema_B_30,Ema_B_50,Ema_B_100,Ema_B_150,Ema_B_200,Ema_B_250
   ,Sma_B_10,Sma_B_20,Sma_B_30,Sma_B_50,Sma_B_100,Sma_B_150,Sma_B_200,Sma_B_250
   ,Smma_B_10,Smma_B_20,Smma_B_30,Smma_B_50,Smma_B_100,Smma_B_150,Smma_B_200,Smma_B_250
   ,Lwma_B_10,Lwma_B_20,Lwma_B_30,Lwma_B_50,Lwma_B_100,Lwma_B_150,Lwma_B_200,Lwma_B_250
   ,Frama_B_10,Frama_B_20,Frama_B_30,Frama_B_50,Frama_B_100,Frama_B_150,Frama_B_200,Frama_B_250
};
input INDICATORSF1 InputEnumF1;

//Indicator Filter 2 String
enum   INDICATORSF2 
{
    F2_NA
};
input INDICATORSF2 InputEnumF2;

//+------------------------------------------------------------------+
//| Indicator Setup                                                  |
//+------------------------------------------------------------------+
//Indicator Entry 1 Variables - Entry Trigger
string IndicatorE1 = (InputEnumE1 == E1_NA) ? "Na" : EnumToString(InputEnumE1);
string IndicatorSignalE1;
int    IndicatorHandleE1[];

//Indicator Filter 1 Variables
string IndicatorF1 = (InputEnumF1 == F1_NA) ? "Na" : EnumToString(InputEnumF1);
string IndicatorSignalF1;
int    IndicatorHandleF1[];

//Indicator Filter 2 Variables
string IndicatorF2 = (InputEnumF2 == F2_NA) ? "Na" : EnumToString(InputEnumF2);
string IndicatorSignalF2;
int    IndicatorHandleF2[];

//Indicator Exit 1 Variables - Exit Trigger
string IndicatorX1 = (InputEnumF1 == F1_NA) ? "Na" : EnumToString(InputEnumF1);
string IndicatorSignalX1;
int    IndicatorHandleX1[];

double GetAtrConfirmed(int atrHandle)
{
   double buf[];
   // Copy 3 values from shift 0:
   // buf[0] = current forming bar
   // buf[1] = last closed bar  <-- we want this
   // buf[2] = older bar
   if(CopyBuffer(atrHandle, 0, 0, 3, buf) <= 0)
   {
      Print("ATR CopyBuffer failed. err=", GetLastError());
      return 0.0;
   }

   return buf[1];
}


//+------------------------------------------------------------------+
//| Expert initialization function                                   |
//+------------------------------------------------------------------+
int OnInit()
{
   //Initiate C Trade
   InitiateTrade(MagicNumber);
   
   StartingEquity = AccountInfoDouble(ACCOUNT_EQUITY);
   
   //Set up multi-symbol EA Tradable Symbols
   InitMultiSymbol();

   //Resize Arrays for Multi-Symbol EA
   ResizeCoreArrays();   
   
   //Resize Indicator Arrays for Multi-Symbol EA
   ResizeIndicatorArrays();

   //Initiate indicator handles for multi-symbol
   if(!InitIndicatorHanldes())
       return(INIT_FAILED);
      
   return(INIT_SUCCEEDED);
}

//+------------------------------------------------------------------+
//| Expert deinitialization function                                 |
//+------------------------------------------------------------------+
void OnDeinit(const int reason)
{
   //Release Indicator Arrays
   ReleaseIndicatorHandles();
}

//+------------------------------------------------------------------+
//| Expert tick function                                             |
//+------------------------------------------------------------------+
void OnTick()
{
   //Declare comment variables
   ExpertComments="";
   TicksReceived++;
  
   //Run multi-symbol loop   
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      //Store symbol vairables
      string CurrentSymbol = SymbolArray[SymbolLoop]; //Get current symbol

      
      //Check for new candle based of opening time of bar 
      if(TimeLastTickProcessed[SymbolLoop] != iTime(CurrentSymbol,Period(),0))
      {
         //Add to tick processed counter and store last tick processed for symbol
         TicksProcessed[SymbolLoop]++; 
         TimeLastTickProcessed[SymbolLoop]  = iTime(CurrentSymbol,Period(),0);  
         
         double atr = GetAtrConfirmed(HandleAtr[SymbolLoop]);
          //Print("ATR confirmed for ", CurrentSymbol, " = ", DoubleToString(atr, 6));
    
         
         //Get any open position directions, reset on each run
         string PositionDirection = "NA";                  
         if(PositionSelectByTicket(TicketNumber[SymbolLoop]) == true)
         {
            if (PositionGetInteger(POSITION_TYPE) == 0)
               PositionDirection = "Long";
            else if (PositionGetInteger(POSITION_TYPE) == 1)
               PositionDirection = "Short";
         }
         else
            PositionDirection = "NA";
           
         //Get Indicator Signals
         IndicatorSignalE1 = GetIndicatorTrigger(IndicatorE1, IndicatorHandleE1[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalF1 = GetIndicatorFilter(IndicatorF1,  IndicatorHandleF1[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalF2 = GetIndicatorFilter(IndicatorF2,  IndicatorHandleF2[SymbolLoop], CurrentSymbol, Period());
         IndicatorSignalX1 = GetIndicatorTrigger(IndicatorX1, IndicatorHandleX1[SymbolLoop], CurrentSymbol, Period());
         
                     
         //Enter Long Trades
         if(
            (PositionDirection == "Short" || PositionDirection == "NA") && //enter if no current trades or short trades
            (IndicatorSignalE1 == "Long"                              ) && //enter on long trigger
            (IndicatorSignalF1 == "Long"  || IndicatorSignalF1 == "NA") && //enter on long filter or no filter indicator is selected
            (IndicatorSignalF2 == "Long"  || IndicatorSignalF2 == "NA")    //enter on long filter or no filter indicator is selected
         )
         {
            TicketNumber[SymbolLoop] = ProcessTradeOpen(CurrentSymbol, ORDER_TYPE_BUY,MagicNumber,atr);       //Open positions and store ticket
            PositionDirection        = "Long";                                                                //Store position direction
         }        
         //Enter Short Trades
         else if(
            (PositionDirection == "Long"  || PositionDirection == "NA") && //enter if no current trades or short trades
            (IndicatorSignalE1 == "Short"                             ) && //enter on short trigger
            (IndicatorSignalF1 == "Short" || IndicatorSignalF1 == "NA") && //enter on short filter or no filter indicator is selected
            (IndicatorSignalF2 == "Short" || IndicatorSignalF2 == "NA")    //enter on short filter or no filter indicator is selected
         )
         {
            TicketNumber[SymbolLoop] = ProcessTradeOpen(CurrentSymbol, ORDER_TYPE_SELL, MagicNumber, atr);     //Open positions and store ticket
            PositionDirection        = "Short";                                                                //Store position direction
         }     
         //Exit Trades  
         else if(
            (PositionDirection == "Long"  && IndicatorSignalX1 == "Short") || //exit long trades on exit indicator short signal
            (PositionDirection == "Short" && IndicatorSignalX1 == "Long")     //exit short trades on exit indicator long signal
         )
         {   
            ProcessTradeClose(CurrentSymbol,TicketNumber[SymbolLoop]);
         }                          
         //Update Symbol Metrics
         SymbolMetrics[SymbolLoop] = CurrentSymbol + 
                                     " | Ticks Processed: " + IntegerToString(TicksProcessed[SymbolLoop]) +
                                     " | Last Candle: " + TimeToString(TimeLastTickProcessed[SymbolLoop]) +
                                     " | Open Ticket: " + IntegerToString(TicketNumber[SymbolLoop]) +
                                     " | Open Ticket Direction: " + PositionDirection +
                                     " | Entry 1 (" + IntegerToString(IndicatorHandleE1[SymbolLoop])+") : " + IndicatorSignalE1 +
                                     " | Filter 1 (" + IntegerToString(IndicatorHandleF1[SymbolLoop])+") : " + IndicatorSignalF1 +
                                     " | Filter 2 (" + IntegerToString(IndicatorHandleF2[SymbolLoop])+") : " + IndicatorSignalF2 +
                                     " | Exit 1 (" + IntegerToString(IndicatorHandleX1[SymbolLoop])+") : " + IndicatorSignalX1                     
                                     ;
      }
      
      //Update expert comments for each symbol
      ExpertComments = ExpertComments + SymbolMetrics[SymbolLoop] + "\n\r";
   }
   //Comment expert behaviour
   Comment("\n\rExpert: ", MagicNumber, "\n\r",
            "MT5 Server Time: ", TimeCurrent(), "\n\r",
            "Ticks Received: ", TicksReceived,"\n\r\n\r",  
            "Symbols Traded:\n\r", 
            ExpertComments
            );
}

//+------------------------------------------------------------------+
//| Multi-Symbol Custom Functions                                    |
//+------------------------------------------------------------------+
//Initiate MultiSymbol Function
void InitMultiSymbol() 
{
   //Set up symbol arrays
   //If current symbol, select symbol from EA settings
   if(AllTradableSymbols == "Current")
   {
      NumberOfTradeableSymbols = 1;
      ArrayResize(SymbolArray,NumberOfTradeableSymbols);
      SymbolArray[0] = Symbol();
      Print("EA will process ", NumberOfTradeableSymbols, " Symbol: ", SymbolArray[0]);
   } 
   //Else test all symbols
   else
   {
      NumberOfTradeableSymbols = StringSplit(AllTradableSymbols, '|', SymbolArray);
      ArrayResize(SymbolArray,NumberOfTradeableSymbols);
      Print("EA will process ", NumberOfTradeableSymbols, " Symbols: ", AllTradableSymbols);
   }
}

//Resize core arrays for multi-symbol EA
void ResizeCoreArrays()
{
   //Resize core arrays for Multi-Symbol EA
   ArrayResize(SymbolMetrics,         NumberOfTradeableSymbols);
   ArrayResize(TicksProcessed,        NumberOfTradeableSymbols); 
   ArrayResize(TimeLastTickProcessed, NumberOfTradeableSymbols);
   ArrayResize(TicketNumber,          NumberOfTradeableSymbols);
}
//+------------------------------------------------------------------+
//| Indicator library custom functions                               |
//+------------------------------------------------------------------+
//Resize indicator arrays for Multi-Symbol EA
void ResizeIndicatorArrays()
{
   ArrayResize(IndicatorHandleE1, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleF1, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleF2, NumberOfTradeableSymbols);
   ArrayResize(IndicatorHandleX1, NumberOfTradeableSymbols);
   ArrayResize(HandleAtr,         NumberOfTradeableSymbols);
}

//Release indicator handles from Metatrader cache for multi-symbol EA
void ReleaseIndicatorHandles()
{
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      IndicatorRelease(IndicatorHandleE1[SymbolLoop]);
      IndicatorRelease(IndicatorHandleF1[SymbolLoop]);
      IndicatorRelease(IndicatorHandleF2[SymbolLoop]);
      IndicatorRelease(IndicatorHandleX1[SymbolLoop]);
      IndicatorRelease(HandleAtr[SymbolLoop]);
   }
   Print("Handle released for all symbols");   
}

//Set up Indicator1 Handle for Multi-Symbol EA
bool InitIndicatorHanldes()
{
   for(int SymbolLoop=0; SymbolLoop < NumberOfTradeableSymbols; SymbolLoop++)
   {
      IndicatorHandleE1[SymbolLoop] = GetIndicatorHandle(IndicatorE1, SymbolArray[SymbolLoop],Period());
      IndicatorHandleF1[SymbolLoop] = GetIndicatorHandle(IndicatorF1, SymbolArray[SymbolLoop],Period());
      IndicatorHandleF2[SymbolLoop] = GetIndicatorHandle(IndicatorF2, SymbolArray[SymbolLoop],Period());
      IndicatorHandleX1[SymbolLoop] = GetIndicatorHandle(IndicatorX1, SymbolArray[SymbolLoop],Period());
      
      // ATR handle per symbol
      HandleAtr[SymbolLoop] = iATR(SymbolArray[SymbolLoop], Period(), AtrPeriod);
      if(HandleAtr[SymbolLoop] == INVALID_HANDLE)
      {
         Print("Failed to create ATR handle for ", SymbolArray[SymbolLoop], " err=", GetLastError());
         return false;
      }
   }
   return true;     
}

//+------------------------------------------------------------------+
//| Process trades custom functions                                  |
//+------------------------------------------------------------------+
//Initiate cTrade and magic number
void InitiateTrade(int ID)
{   
   Trade = new CTrade();
   Trade.SetExpertMagicNumber(ID);
   return;  
}

double CalcRiskLots(string symbol, double entryPrice, double stopLossPrice)
{
   // How much money you want to risk
   double equityForRisk = RiskCompounding ? AccountInfoDouble(ACCOUNT_EQUITY) : StartingEquity;
   double riskMoney     = equityForRisk * RiskPercent;

   // Symbol properties
   double tickSize   = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_SIZE);
   double tickValue  = SymbolInfoDouble(symbol, SYMBOL_TRADE_TICK_VALUE);
   int    digits     = (int)SymbolInfoInteger(symbol, SYMBOL_DIGITS);

   // Some brokers quote tickValue differently for 3/2-digit symbols (JPY pairs etc.)
   if(digits <= 3)
      tickValue /= 100.0;

   double point      = SymbolInfoDouble(symbol, SYMBOL_POINT);
   double ticksPerPoint = tickSize / point;
   double pointValue    = tickValue / ticksPerPoint; // money per 1 point, per 1 lot

   // Stop distance in ticks
   double stopTicks = MathAbs((entryPrice - stopLossPrice) / tickSize);
   if(stopTicks <= 0)
      return 0.0;

   // Raw lot size
   double lots = riskMoney / (stopTicks * pointValue);

   // Normalize to broker volume rules
   double volMin  = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MIN);
   double volMax  = SymbolInfoDouble(symbol, SYMBOL_VOLUME_MAX);
   double volStep = SymbolInfoDouble(symbol, SYMBOL_VOLUME_STEP);

   // Round down to step (safer than rounding up)
   lots = MathFloor(lots / volStep) * volStep;

   // Clamp
   if(lots < volMin) lots = volMin;
   if(lots > volMax) lots = volMax;

   return lots;
}


//Process trades function - Fixed Lot Position Size, No SL/TP
ulong ProcessTradeOpen(string CurrentSymbol, ENUM_ORDER_TYPE OrderType, int ID, double AtrValue) export

{
   //Set symbol string and variables 
   int    SymbolDigits    = (int) SymbolInfoInteger(CurrentSymbol,SYMBOL_DIGITS); //note - typecast required to remove error
   double Price           = 0.0;
   double StopLossPrice   = 0.0;
   double TakeProfitPrice = 0.0;
   
   //Open buy or sell orders
   if(OrderType == ORDER_TYPE_BUY)
   {
      Price = NormalizeDouble(SymbolInfoDouble(CurrentSymbol, SYMBOL_ASK), SymbolDigits);
   } 
   else if(OrderType == ORDER_TYPE_SELL)
   {
      Price = NormalizeDouble(SymbolInfoDouble(CurrentSymbol, SYMBOL_BID), SymbolDigits);
   }
   
    if(AtrValue <= 0.0)
   {
      Print("ATR not ready for ", CurrentSymbol, " - skipping trade open.");
      return 0;
   }
   
   if(OrderType == ORDER_TYPE_BUY)
   {
      StopLossPrice   = NormalizeDouble(Price - (AtrValue * AtrLossMulti), SymbolDigits);
      TakeProfitPrice = NormalizeDouble(Price + (AtrValue * AtrProfitMulti), SymbolDigits);
   }
   else if(OrderType == ORDER_TYPE_SELL)
   {
      StopLossPrice   = NormalizeDouble(Price + (AtrValue * AtrLossMulti), SymbolDigits);
      TakeProfitPrice = NormalizeDouble(Price - (AtrValue * AtrProfitMulti), SymbolDigits);
   }
   
   // --- NNFX risk-based lot sizing (uses ATR stop distance) ---
   double Lots = CalcRiskLots(CurrentSymbol, Price, StopLossPrice);
   if(Lots <= 0.0)
   {
      Print("Lot calc failed for ", CurrentSymbol, " - skipping trade.");
      return 0;
   }
   
   Print("STEP1 LOTS ", CurrentSymbol,
      " Lots=", DoubleToString(Lots, 2),
      " ATR=", DoubleToString(AtrValue, 6),
      " Price=", DoubleToString(Price, SymbolDigits),
      " SL=", DoubleToString(StopLossPrice, SymbolDigits));

   
      Print("RISK LOTS ", CurrentSymbol,
         " Equity=", DoubleToString(AccountInfoDouble(ACCOUNT_EQUITY), 2),
         " Risk%=", DoubleToString(RiskPercent*100.0, 2),
         " Lots=", DoubleToString(Lots, 2));


   
   // Optional debug (keep for now)
   Print("OPEN ", CurrentSymbol,
         " ATR=", DoubleToString(AtrValue, 6),
         " Price=", DoubleToString(Price, SymbolDigits),
         " SL=", DoubleToString(StopLossPrice, SymbolDigits),
         " TP=", DoubleToString(TakeProfitPrice, SymbolDigits));

        
   //Close any current positions and open new position
   Trade.PositionClose(CurrentSymbol);
   Trade.SetExpertMagicNumber(ID);  
   Trade.PositionOpen(CurrentSymbol,OrderType,Lots,Price,StopLossPrice,TakeProfitPrice,__FILE__);
   
   
   //Get Position Ticket Number - run through open positions and store ticket number whcih matches with current symbol
   //Note - history deals total does not work for multisymbol
   ulong  Ticket = 0;
   int Total = PositionsTotal();
   for (int i=Total -1; i>=0; i--)
      {
         ulong GetTicket  = PositionGetTicket(i);
         string GetSymbol = PositionGetSymbol(i);
         if (CurrentSymbol == GetSymbol)
            Ticket = GetTicket;
      }
   
   //Print successful
   Print("Trade Processed For Ticket ", Ticket, " Symbol ", CurrentSymbol," OrderType ",OrderType, " Lot Size ", Lots);
   
   return(Ticket);
}

//Process trades close
void   ProcessTradeClose(string CurrentSymbol, ulong Ticket) export
{
   Trade.PositionClose(Ticket);
   
   //Print successful
   Print("Trade Closed For Ticket ", Ticket, " Symbol ", CurrentSymbol);
}
//+------------------------------------------------------------------+
